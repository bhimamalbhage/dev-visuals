{
    "systemDesign": {
        "diagrams": [
            {
                "id": "architecture-patterns",
                "name": "Architecture Patterns"
            },
            {
                "id": "scalability",
                "name": "Scalability"
            },
            {
                "id": "databases",
                "name": "Databases"
            },
            {
                "id": "caching",
                "name": "Caching"
            },
            {
                "id": "api-design",
                "name": "API Design"
            },
            {
                "id": "communication",
                "name": "Communication"
            },
            {
                "id": "frontend-system-design",
                "name": "Frontend System Design"
            }
        ],
        "architecturePatterns": [
            {
                "id": "monolithic",
                "name": "Monolithic",
                "icon": "HardDrive",
                "description": "A single, unified codebase where all components and modules are combined into one application.",
                "advantages": [
                    "Simple development and deployment",
                    "Easier testing and debugging",
                    "Good performance for small applications",
                    "Simpler team structure initially"
                ],
                "disadvantages": [
                    "Difficult to scale individual components",
                    "Technology stack tied to initial choices",
                    "Larger codebases get unwieldy over time",
                    "Continuous deployment becomes challenging"
                ],
                "example": "Traditional enterprise applications like older banking systems, internal corporate tools, or simple CRUD applications."
            },
            {
                "id": "microservices",
                "name": "Microservices",
                "icon": "Layers",
                "description": "An architectural approach where an application is built as a collection of small, independently deployable services.",
                "advantages": [
                    "Independent scaling of services",
                    "Technology diversity across services",
                    "Resilience (failure isolation)",
                    "Easier continuous deployment",
                    "Teams can develop independently"
                ],
                "disadvantages": [
                    "Increased operational complexity",
                    "Network latency between services",
                    "Debugging across services is challenging",
                    "Data consistency challenges",
                    "Higher infrastructure costs"
                ],
                "example": "Modern distributed systems like Netflix, Uber, or Amazon's retail platform where different teams own different services."
            },
            {
                "id": "serverless",
                "name": "Serverless",
                "icon": "Clock",
                "description": "A cloud computing execution model where the cloud provider dynamically manages the allocation of resources.",
                "advantages": [
                    "Zero infrastructure management",
                    "Pay-per-use pricing model",
                    "Automatic scaling",
                    "Faster time to market",
                    "Focus on code, not infrastructure"
                ],
                "disadvantages": [
                    "Cold start latency",
                    "Limited execution duration",
                    "Vendor lock-in concerns",
                    "Limited local testing",
                    "Complex debugging"
                ],
                "example": "AWS Lambda functions for image processing, API Gateway backends, or event-triggered workflows like form submissions or IoT events."
            },
            {
                "id": "eventdriven",
                "name": "Event-Driven",
                "icon": "BarChart",
                "description": "A design pattern where the flow of the program is determined by events like user actions, sensor outputs, or messages from other programs.",
                "advantages": [
                    "Loose coupling between components",
                    "Good for asynchronous workflows",
                    "Highly scalable and reactive",
                    "Better fault isolation",
                    "Easy to extend with new event handlers"
                ],
                "disadvantages": [
                    "Complex event flows can be hard to debug",
                    "Event versioning challenges",
                    "Eventual consistency complexities",
                    "Potentially higher latency",
                    "Ordering guarantees may be difficult"
                ],
                "example": "IoT systems, real-time analytics platforms, or financial trading platforms where events trigger specific actions or workflows."
            }
        ],
        "networking": {
            "diagrams": [
                {
                    "id": "dns",
                    "name": "DNS",
                    "icon": "Globe"
                },
                {
                    "id": "tcp-udp",
                    "name": "TCP vs UDP",
                    "icon": "ArrowLeftRight"
                },
                {
                    "id": "http-https",
                    "name": "HTTP vs HTTPS",
                    "icon": "Lock"
                },
                {
                    "id": "tls-ssl",
                    "name": "TLS/SSL",
                    "icon": "ShieldCheck"
                },
                {
                    "id": "websockets",
                    "name": "WebSockets",
                    "icon": "RefreshCw"
                },
                {
                    "id": "grpc",
                    "name": "gRPC",
                    "icon": "Zap"
                },
                {
                    "id": "forward-reverse-proxy",
                    "name": "Forward vs Reverse Proxy",
                    "icon": "ArrowLeftRight"
                }
            ],
            "concepts": {
                "dns": {
                    "title": "DNS (Domain Name System)",
                    "description": "The phonebook of the internet. Translates human-readable domain names (google.com) to IP addresses (142.250.190.46).",
                    "details": [
                        "Recursive Query: Resolver asks Root -> TLD -> Authoritative servers.",
                        "Iterative Query: Resolver refers client to next server.",
                        "A Record: IPv4 address.",
                        "AAAA Record: IPv6 address.",
                        "CNAME: Alias to another domain.",
                        "TTL: Time To Live (caching duration)."
                    ]
                },
                "tcp-udp": {
                    "title": "TCP vs UDP",
                    "description": "Transport Layer protocols that determine how data is sent over the network.",
                    "comparison": [
                        {
                            "feature": "Connection",
                            "tcp": "Connection-oriented (Handshake)",
                            "udp": "Connectionless (Fire & Forget)"
                        },
                        {
                            "feature": "Reliability",
                            "tcp": "Guaranteed delivery, retries",
                            "udp": "No guarantee, packet loss ok"
                        },
                        {
                            "feature": "Ordering",
                            "tcp": "Ordered packets",
                            "udp": "Unordered"
                        },
                        {
                            "feature": "Speed",
                            "tcp": "Slower (overhead)",
                            "udp": "Faster (low overhead)"
                        },
                        {
                            "feature": "Use Cases",
                            "tcp": "Web, Email, File Transfer",
                            "udp": "Streaming, Gaming, VoIP"
                        }
                    ]
                },
                "http-https": {
                    "title": "HTTP vs HTTPS",
                    "description": "HyperText Transfer Protocol. HTTPS adds a layer of security (TLS/SSL) to encrypt communications.",
                    "features": [
                        "HTTP: Plain text, port 80, fast but insecure.",
                        "HTTPS: Encrypted, port 443, authenticates server, ensures integrity."
                    ]
                },
                "tls-ssl": {
                    "title": "TLS/SSL Handshake",
                    "description": "Transport Layer Security. The process of negotiating encryption keys between client and server.",
                    "steps": [
                        "1. Client Hello: Cipher suites, random bytes.",
                        "2. Server Hello: Selected cipher, certificate, random bytes.",
                        "3. Authentication: Client verifies server certificate.",
                        "4. Key Exchange: Generate session keys (Pre-master secret).",
                        "5. Finished: Encrypted communication begins."
                    ]
                },
                "websockets": {
                    "title": "WebSockets",
                    "description": "Protocol for full-duplex communication channels over a single TCP connection.",
                    "benefits": [
                        "Real-time data transfer.",
                        "Low latency (no polling overhead).",
                        "Persistent connection.",
                        "Ideal for chat apps, live feeds, collaborative editing."
                    ]
                },
                "grpc": {
                    "title": "gRPC",
                    "description": "Modern open source high performance Remote Procedure Call (RPC) framework.",
                    "features": [
                        "Built on HTTP/2 (multiplexing, binary framing).",
                        "Uses Protocol Buffers (smaller, faster than JSON).",
                        "Supports bidirectional streaming."
                    ]
                },
                "forward-reverse-proxy": {
                    "title": "Forward vs Reverse Proxy",
                    "description": "Proxies act as intermediaries. The key difference is 'who' they represent.",
                    "comparison": [
                        {
                            "feature": "Represents",
                            "forward": "Client (User)",
                            "reverse": "Server (Backend)"
                        },
                        {
                            "feature": "Position",
                            "forward": "User -> Proxy -> Internet",
                            "reverse": "Internet -> Proxy -> Server"
                        },
                        {
                            "feature": "Primary Goal",
                            "forward": "Anonymity, Bypassing restrictions",
                            "reverse": "Load Balancing, Security, Caching"
                        },
                        {
                            "feature": "Visibility",
                            "forward": "Server doesn't know real Client IP",
                            "reverse": "Client doesn't know real Server IP"
                        }
                    ]
                }
            }
        },
        "scalabilityConcepts": [
            {
                "id": "vertical-scaling",
                "name": "Vertical Scaling",
                "icon": "BarChart",
                "description": "Scaling up (scaling vertically) means adding more resources (CPU/RAM) to your existing server.",
                "pros": [
                    "Simple to implement",
                    "No code changes required",
                    "Lower administrative overhead"
                ],
                "cons": [
                    "Hardware limits (finite ceiling)",
                    "Single point of failure",
                    "Can be expensive at high end"
                ]
            },
            {
                "id": "horizontal-scaling",
                "name": "Horizontal Scaling",
                "icon": "Layers",
                "description": "Scaling out (scaling horizontally) means adding more servers to your pool of resources.",
                "pros": [
                    "Ideally infinite scale",
                    "Redundancy/Failover",
                    "Cost-effective with commodity hardware"
                ],
                "cons": [
                    "Complex (needs load balancing)",
                    "Network latency",
                    "Data consistency challenges"
                ]
            },
            {
                "id": "load-balancing",
                "name": "Load Balancing",
                "icon": "Globe",
                "description": "Distributes incoming network traffic across a group of backend servers.",
                "pros": [
                    "Prevents overload",
                    "High availability",
                    "Flexibility to add/remove servers"
                ],
                "cons": [
                    "Can be a bottleneck",
                    "Complexity in configuration",
                    "Session persistence issues"
                ],
                "types": [
                    {
                        "name": "L4 (Transport)",
                        "desc": "Routes based on IP/Port. Fast, simple. No content inspection."
                    },
                    {
                        "name": "L7 (Application)",
                        "desc": "Routes based on URL, Headers, Content. Smarter, but slower (CPU intensive)."
                    }
                ]
            },
            {
                "id": "reverse-proxy",
                "name": "Reverse Proxy",
                "icon": "ArrowLeftRight",
                "description": "A server that sits in front of web servers and forwards client requests to those web servers.",
                "pros": [
                    "Security (hides backend IPs)",
                    "SSL Termination",
                    "Caching & Compression",
                    "Load Balancing"
                ],
                "cons": [
                    "Single point of failure (if not redundant)",
                    "Added complexity",
                    "Potential bottleneck"
                ]
            },
            {
                "id": "cdn",
                "name": "CDN",
                "icon": "Globe",
                "description": "Content Delivery Network. Geographically distributed servers that cache content close to users.",
                "pros": [
                    "Lower latency (faster load times)",
                    "Reduced bandwidth costs",
                    "DDoS protection",
                    "High availability"
                ],
                "cons": [
                    "Cache invalidation challenges",
                    "Cost for high traffic",
                    "Restricted to static content (mostly)"
                ]
            }
        ],
        "databases": {
            "tabs": [
                {
                    "id": "sql-vs-nosql",
                    "name": "SQL vs NoSQL"
                },
                {
                    "id": "cap",
                    "name": "CAP Theorem"
                },
                {
                    "id": "sharding",
                    "name": "Replication & Sharding"
                }
            ],
            "sql": {
                "title": "SQL (Relational)",
                "items": [
                    "Structured data, predefined schema",
                    "ACID transactions (Atomicity, Consistency, Isolation, Durability)",
                    "Vertical scaling is common",
                    "Good for complex queries (Joins)"
                ],
                "icon": "Database",
                "examples": "PostgreSQL, MySQL"
            },
            "nosql": {
                "title": "NoSQL (Non-Relational)",
                "items": [
                    "Unstructured/Semi-structured data",
                    "BASE (Basically Available, Soft state, Eventual consistency)",
                    "Horizontal scaling is easier",
                    "Flexible schema"
                ],
                "icon": "FileCode",
                "examples": "MongoDB, Redis, Cassandra"
            },
            "cap": {
                "title": "CAP Theorem",
                "description": "In a distributed system, you can only satisfy two of the three guarantees at the same time: Consistency, Availability, Partition Tolerance.",
                "note": "* Partition Tolerance is usually non-negotiable in distributed systems, so the choice is typically between CP (Consistency/Partition Tolerance) and AP (Availability/Partition Tolerance)."
            },
            "replication": {
                "title": "Replication",
                "description": "Duplicating data across multiple servers.",
                "items": [
                    "Increases availability (failover)",
                    "Improves read performance (read replicas)",
                    "Master-Slave vs Master-Master"
                ]
            },
            "sharding": {
                "title": "Sharding",
                "description": "Partitioning data across multiple servers.",
                "items": [
                    "Horizontal scaling for data",
                    "Complex queries become harder",
                    "Uses a Shard Key (e.g. UserID)"
                ]
            }
        },
        "caching": {
            "layers": {
                "title": "Caching Layers",
                "items": [
                    {
                        "name": "Client",
                        "desc": "Browser/App Cache"
                    },
                    {
                        "name": "CDN",
                        "desc": "Edge Caching"
                    },
                    {
                        "name": "App Server",
                        "desc": "Local Cache"
                    },
                    {
                        "name": "Distributed",
                        "desc": "Redis/Memcached"
                    }
                ]
            },
            "evictionPolicies": {
                "title": "Eviction Policies",
                "items": [
                    {
                        "name": "LRU (Least Recently Used)",
                        "desc": "Discards the least recently used items first. Good for most general use cases."
                    },
                    {
                        "name": "LFU (Least Frequently Used)",
                        "desc": "Counts how often an item is needed. Good if some items are accessed much more often than others."
                    },
                    {
                        "name": "FIFO (First In First Out)",
                        "desc": "Discards items in the order they were added."
                    }
                ]
            },
            "writeStrategies": {
                "title": "Writes Strategies",
                "items": [
                    {
                        "name": "Write-Through",
                        "desc": "Write to cache and DB at the same time. Safe but slower write."
                    },
                    {
                        "name": "Write-Around",
                        "desc": "Write to DB, bypass cache. detailed read fills cache. Reduces cache pollution."
                    },
                    {
                        "name": "Write-Back",
                        "desc": "Write to cache, async write to DB. Fast logical write, risk of data loss on crash."
                    }
                ]
            }
        },
        "apiDesign": {
            "styles": [
                {
                    "title": "REST",
                    "subtitle": "Representational State Transfer",
                    "items": [
                        "Resource-based (nouns)",
                        "Standard HTTP methods (GET, POST...)",
                        "Stateless",
                        "Great for public APIs"
                    ],
                    "color": "blue"
                },
                {
                    "title": "GraphQL",
                    "subtitle": "Query Language for APIs",
                    "items": [
                        "Client requests exactly what it needs",
                        "Single endpoint",
                        "Solves over/under-fetching",
                        "Complex backend implementation"
                    ],
                    "color": "pink"
                },
                {
                    "title": "gRPC",
                    "subtitle": "Remote Procedure Call",
                    "items": [
                        "Uses Protocol Buffers (fast)",
                        "Strictly typed",
                        "Great for internal microservices",
                        "Requires code generation"
                    ],
                    "color": "green"
                }
            ],
            "statusCodes": {
                "title": "Common HTTP Status Codes",
                "items": [
                    {
                        "code": "200",
                        "desc": "OK",
                        "type": "success"
                    },
                    {
                        "code": "201",
                        "desc": "Created",
                        "type": "success"
                    },
                    {
                        "code": "400",
                        "desc": "Bad Request",
                        "type": "warning"
                    },
                    {
                        "code": "401",
                        "desc": "Unauthorized",
                        "type": "warning"
                    },
                    {
                        "code": "403",
                        "desc": "Forbidden",
                        "type": "warning"
                    },
                    {
                        "code": "404",
                        "desc": "Not Found",
                        "type": "warning"
                    },
                    {
                        "code": "500",
                        "desc": "Server Error",
                        "type": "error"
                    },
                    {
                        "code": "502",
                        "desc": "Bad Gateway",
                        "type": "error"
                    }
                ]
            }
        },
        "messaging": {
            "concepts": [
                {
                    "id": "message-queues",
                    "name": "Message Queues",
                    "icon": "Layers",
                    "description": "Asynchronous communication buffers between services. Producers send messages, Consumers process them.",
                    "pros": [
                        "Decoupling of services",
                        "Buffering / Load smoothing",
                        "Reliability (job persistence)"
                    ],
                    "cons": [
                        "Added operational complexity",
                        "Eventual consistency",
                        "Ordering challenges"
                    ],
                    "example": "RabbitMQ, Amazon SQS, ActiveMQ"
                },
                {
                    "id": "pub-sub",
                    "name": "Pub/Sub",
                    "icon": "RefreshCw",
                    "description": "Publish/Subscribe pattern. Publishers send messages to a topic; all subscribers to that topic receive a copy.",
                    "pros": [
                        "One-to-many communication",
                        "Loose coupling",
                        "Scalable consumer groups"
                    ],
                    "cons": [
                        "Message delivery guarantees vary",
                        "Consumer management"
                    ],
                    "example": "Google Cloud Pub/Sub, Redis Pub/Sub, SNS"
                },
                {
                    "id": "kafka",
                    "name": "Kafka Concepts",
                    "icon": "Server",
                    "description": "Distributed event streaming platform. Durable, high-throughput, and scalable.",
                    "details": [
                        "Topic: Category/feed name for records.",
                        "Partition: Ordered, immutable sequence of records.",
                        "Offset: Unique identifier for a record within a partition.",
                        "Consumer Group: Set of consumers sharing the work."
                    ],
                    "example": "Apache Kafka, Confluent"
                },
                {
                    "id": "dlq",
                    "name": "Dead Letter Queue",
                    "icon": "ShieldCheck",
                    "description": "A holding queue for messages that cannot be processed successfully after max retries.",
                    "pros": [
                        "Prevents data loss",
                        "Isolates bad data for analysis",
                        "Keeps main queue unblocked"
                    ],
                    "example": "SQS DLQ, RabbitMQ Dead Letter Exchange"
                },
                {
                    "id": "event-sourcing",
                    "name": "Event Sourcing",
                    "icon": "Database",
                    "description": "Storing state as a sequence of events rather than just the current state.",
                    "pros": [
                        "Complete audit trail",
                        "Temporal query (time travel)",
                        "High write throughput"
                    ],
                    "cons": [
                        "Complex query logic (need snapshots)",
                        "Event schema evolution is hard",
                        "Storage growth"
                    ],
                    "example": "Banking ledgers, Git version control"
                },
                {
                    "id": "cqrs",
                    "name": "CQRS",
                    "icon": "ArrowLeftRight",
                    "description": "Command Query Responsibility Segregation. Separating read and write operations into different models.",
                    "pros": [
                        "Optimized read/write schemas",
                        "Independent scaling of Reads vs Writes",
                        "Security separation"
                    ],
                    "cons": [
                        "Increased complexity",
                        "Data consistency lag (Eventual consistency)"
                    ],
                    "example": "High-traffic e-commerce systems, collaborative tools"
                }
            ]
        },
        "distributedSystems": {
            "concepts": [
                {
                    "id": "cap-theorem",
                    "name": "CAP Theorem",
                    "icon": "Database",
                    "description": "In a distributed system, you can only pick TWO: Consistency, Availability, Partition Tolerance.",
                    "analogy": "The 'Fast, Good, Cheap' triangle. You can't have all three.",
                    "flow": {
                        "title": "Network Partition Scenario",
                        "steps": [
                            "1. Network fails between Data Center A and B (Partition occurs - P).",
                            "2. You MUST have P to be distributed.",
                            "3. User writes to Data Center A.",
                            "4. System Choice: Do we accept the write?",
                            "5. Option CP: Refuse write (Error) -> Consistent but Unavailable.",
                            "6. Option AP: Accept write -> Available but Inconsistent (Data Center B doesn't know)."
                        ]
                    },
                    "details": [
                        "CP: Consistency + Partition Tolerance (e.g. Banking - prevent double spend).",
                        "AP: Availability + Partition Tolerance (e.g. TikTok Feed - show old videos if needed, just don't crash).",
                        "CA: Theoretical only. If network breaks, you must choose C or A."
                    ],
                    "example": "Banking needs CP. Social Feeds need AP."
                },
                {
                    "id": "consistency-models",
                    "name": "Consistency Models",
                    "icon": "Clock",
                    "description": "Rules for when a write becomes visible to readers.",
                    "analogy": "Shared Google Doc (Strong) vs Email Attachment (Eventual).",
                    "types": [
                        {
                            "name": "Strong Consistency",
                            "desc": "Everyone sees the same data at the same time (like a Google Doc)."
                        },
                        {
                            "name": "Eventual Consistency",
                            "desc": "Updates propagate slowly. You might see old data for a bit (like Email)."
                        }
                    ],
                    "example": "Strong: Bank Balance. Eventual: YouTube View Count."
                },
                {
                    "id": "leader-election",
                    "name": "Leader Election",
                    "icon": "ShieldCheck",
                    "description": "Deciding which node is the 'Boss' to coordinate tasks.",
                    "analogy": "Class Monitor. If the teacher leaves, students vote for a monitor to keep order.",
                    "flow": {
                        "title": "Leader Crash Scenario",
                        "steps": [
                            "1. Leader Node crashes.",
                            "2. Worker nodes stop receiving 'Heartbeats'.",
                            "3. Workers trigger an 'Election'.",
                            "4. Nodes vote (based on ID, uptime, etc.).",
                            "5. New Leader is elected.",
                            "6. System resumes normal operation."
                        ]
                    },
                    "details": [
                        "Needed to avoid conflicts (Split Brain).",
                        "Used in databases (Primary/Replica)."
                    ],
                    "example": "Kubernetes Controller, Kafka Controller."
                },
                {
                    "id": "consensus",
                    "name": "Consensus (Raft/Paxos)",
                    "icon": "Handshake",
                    "description": "Getting a group of computers to agree on a single value, even if some crash.",
                    "analogy": "Group of friends deciding on lunch. You need a majority to agree before it's official.",
                    "flow": {
                        "title": "Raft Log Replication",
                        "steps": [
                            "1. Leader receives a command (e.g., 'Set X=5').",
                            "2. Leader appends it to its log (uncommitted).",
                            "3. Leader sends 'AppendEntries' to all Followers.",
                            "4. Followers write to their logs and send 'Success'.",
                            "5. Leader gets majority success? -> COMMIT.",
                            "6. Leader tells Followers to COMMIT.",
                            "7. Client gets 'Success'."
                        ]
                    },
                    "details": [
                        "Raft: Easier to understand. Uses Leader Election + Log Replication.",
                        "Goal: Fault Tolerance. System works as long as a quorum (majority) is up."
                    ],
                    "example": "Etcd (Kubernetes), Zookeeper."
                },
                {
                    "id": "distributed-locking",
                    "name": "Distributed Locking",
                    "icon": "Lock",
                    "description": "Ensuring only ONE process can access a resource at a time across different servers.",
                    "analogy": "Airplane Toilet. Only one person can be inside; the 'Occupied' sign tells others to wait.",
                    "flow": {
                        "title": "Cron Job Lock Scenario",
                        "steps": [
                            "1. Cron Job starts on Server A and Server B at the same time.",
                            "2. Server A tries to set 'Lock:Cron' in Redis.",
                            "3. Success! Server A gets the lock (with a 30s timeout).",
                            "4. Server B tries to set 'Lock:Cron'...",
                            "5. Fails! Lock exists. Server B gives up (or waits).",
                            "6. Server A finishes work and deletes the key (Release)."
                        ]
                    },
                    "details": [
                        "Prevents race conditions (e.g., charging a user twice).",
                        "Must handle node failures (TTL/Leases so locks don't stay forever)."
                    ],
                    "example": "Preventing a cron job from running twice, Flash Sales."
                },
                {
                    "id": "quorum",
                    "name": "Quorum",
                    "icon": "Users",
                    "description": "The minimum number of votes needed to perform an operation.",
                    "analogy": "Parliament. You need 51% of members present to pass a law.",
                    "flow": {
                        "title": "Database Write Quorum",
                        "steps": [
                            "1. You have 3 Database Nodes (N=3).",
                            "2. You set Write Quorum (W) = 2.",
                            "3. Client sends write to DB.",
                            "4. DB sends write to Node 1, 2, and 3.",
                            "5. Node 1 and Node 2 reply 'Success'.",
                            "6. That's 2 acks! (Met Quorum).",
                            "7. Client gets 'Success' (even if Node 3 is slow/down)."
                        ]
                    },
                    "details": [
                        "N = Total Nodes, R = Read Quorum, W = Write Quorum.",
                        "Strong Consistency Rule: R + W > N."
                    ],
                    "example": "Cassandra (tunable consistency), DynamoDB."
                },
                {
                    "id": "gossip-protocol",
                    "name": "Gossip Protocol",
                    "icon": "MessageCircle",
                    "description": "Nodes randomly share info with neighbors until everyone knows.",
                    "analogy": "Viral Rumors. You tell 2 friends, they tell 2 friends... soon the whole school knows.",
                    "flow": {
                        "title": "Cluster State Propagation",
                        "steps": [
                            "1. Node A detects that Node Z is DOWN.",
                            "2. Node A tells random neighbors (Node B and C).",
                            "3. Node B tells Node D and E.",
                            "4. Node C tells Node F.",
                            "5. Within seconds, the whole cluster knows 'Node Z is DOWN'.",
                            "6. No central coordinate needed."
                        ]
                    },
                    "details": [
                        "Scalable and Fault Tolerant.",
                        "Eventual Consistency.",
                        "Used for failure detection."
                    ],
                    "example": "Cassandra ring, Amazon S3, Bitcoin."
                },
                {
                    "id": "vector-clocks",
                    "name": "Vector Clocks",
                    "icon": "Clock",
                    "description": "A way to track 'what happened before what' without trusting wall clocks.",
                    "analogy": "Git Commit History. We know feature-branch came after master because it has all of master's history + new stuff.",
                    "details": [
                        "Replaces physical time (which drifts).",
                        "Helps resolve conflicts (e.g. two people editing the same file offline)."
                    ],
                    "example": "Riak, Amazon Dynamo."
                },
                {
                    "id": "split-brain",
                    "name": "Split Brain",
                    "icon": "Zap",
                    "description": "When the network breaks and TWO nodes think they are the Boss.",
                    "analogy": "Two Bosses giving contradictory orders because they can't talk to each other.",
                    "flow": {
                        "title": "Database Failover Crisis",
                        "steps": [
                            "1. Primary DB (A) loses connection to Replica (B).",
                            "2. Replica (B) thinks Primary (A) is dead.",
                            "3. Replica (B) promotes itself to Primary.",
                            "4. But Primary (A) is still alive and taking writes!",
                            "5. Now you have TWO Primaries accepting different data.",
                            "6. Result: Data corruption/loss when they reconnect."
                        ]
                    },
                    "details": [
                        "Prevention: Fencing, Quorums (Odd number of nodes).",
                        "STONITH (Shoot The Other Node In The Head)."
                    ],
                    "example": "Elasticsearch cluster partition, Database failover gone wrong."
                }
            ]
        },
        "communication": {
            "patterns": [
                {
                    "id": "polling",
                    "name": "Short Polling",
                    "icon": "RefreshCw",
                    "description": "The client keeps asking the server 'Do you have new data?' at fixed intervals (e.g., every 5 seconds).",
                    "analogy": "Kids in the back seat asking 'Are we there yet?' every minute.",
                    "flow": {
                        "title": "Dashboard Refresh Flow",
                        "steps": [
                            "1. Client: 'Any new data?'",
                            "2. Server: 'No.'",
                            "3. Client waits 5 seconds...",
                            "4. Client: 'Any new data?'",
                            "5. Server: 'No.'",
                            "6. Client waits 5 seconds...",
                            "7. Client: 'Any new data?'",
                            "8. Server: 'Yes! Here it is.'",
                            "9. Client displays data."
                        ]
                    },
                    "qa": [
                        {
                            "q": "Is this efficient?",
                            "a": "Not really. Most checks return 'empty', wasting bandwidth and server power processing useless requests."
                        },
                        {
                            "q": "When should I use it?",
                            "a": "For non-critical data that doesn't change often (e.g., refreshing a weather widget every 10 mins)."
                        }
                    ],
                    "pros": [
                        "Simple to implement",
                        "Good for less frequent updates"
                    ],
                    "cons": [
                        "Wasted resources (empty checks)",
                        "High latency (wait for next poll)",
                        "Server load"
                    ],
                    "example": "Legacy dashboards, Weather widgets."
                },
                {
                    "id": "long-polling",
                    "name": "Long Polling",
                    "icon": "Clock",
                    "description": "The client asks for data, and the server *holds* the connection open until data is available.",
                    "analogy": "Ordering a pizza and getting a buzzer. You wait, and it buzzes ONLY when the pizza is ready.",
                    "flow": {
                        "title": "Uber Eats Order Status",
                        "steps": [
                            "1. Client: 'Is my order ready?' (Request opens)",
                            "2. Server: ... (Holds request open, waiting for restaurant)",
                            "3. [Time passes...]",
                            "4. Restaurant: 'Order Ready!'",
                            "5. Server: 'Yes! Order is ready.' (Responses sent immediately)",
                            "6. Client: displays 'Ready', then immediately opens NEW request for 'Driver Assigned?'"
                        ]
                    },
                    "qa": [
                        {
                            "q": "Is this real-time?",
                            "a": "Almost. It's much faster than short polling, but there's a small delay while the client reconnects after receiving data."
                        }
                    ],
                    "pros": [
                        "Better than short polling for real-time",
                        "Works over standard HTTP"
                    ],
                    "cons": [
                        "Server must manage open connections",
                        "Request/Response overhead still exists"
                    ],
                    "example": "Chat apps (before WebSockets), Notification updates."
                },
                {
                    "id": "websockets",
                    "name": "WebSockets",
                    "icon": "ArrowLeftRight",
                    "description": "A persistent, full-duplex communication channel over a single TCP connection.",
                    "handshake": {
                        "steps": [
                            "1. Client sends HTTP Request with `Upgrade: websocket` and `Connection: Upgrade` headers.",
                            "2. Client sends a `Sec-WebSocket-Key` (random base64 string).",
                            "3. Server validates, switches protocols, and responds with HTTP 101 Switching Protocols.",
                            "4. Server sends `Sec-WebSocket-Accept` header (derived from client key) to prove it received the handshake.",
                            "5. Connection is now upgraded to a persistent TCP socket for bidirectional binary/text data."
                        ]
                    },
                    "flow": {
                        "title": "WhatsApp Message Flow",
                        "steps": [
                            "1. User A opens WhatsApp -> App establishes/resumes WebSocket connection to Chat Server.",
                            "2. User A types 'Hello' and hits send.",
                            "3. Client pushes message payload (encrypted) via WebSocket to Server.",
                            "4. Server receives message, stores it in DB (for history), and acknowledges receipt to User A (single tick).",
                            "5. Server checks if User B is connected via WebSocket.",
                            "6. IF Connected: Server pushes message to User B instantly.",
                            "7. IF Disconnected: Server holds message (or uses Push Notification service like FCM/APNs to wake up User B).",
                            "8. User B receives message -> App sends 'Delivered' ack via WebSocket -> Server updates User A (double tick)."
                        ]
                    },
                    "qa": [
                        {
                            "q": "Do I have 100 connections for 100 chats?",
                            "a": "No. You have ONE WebSocket connection to the WhatsApp server. All messages for all 100 chats flow through this single pipe. The payload contains the 'chatID' to route it to the correct UI thread."
                        },
                        {
                            "q": "When does the connection start/close?",
                            "a": "Start: When you open the app (foreground) or a background service starts. Close: When you kill the app, lose internet, or the OS kills the background process to save battery."
                        },
                        {
                            "q": "What happens if internet drops?",
                            "a": "The TCP connection breaks. The client detects this (heartbeat failure) and attempts to reconnect. Queued messages are sent once reconnected."
                        }
                    ],
                    "pros": [
                        "True real-time (low latency)",
                        "Bi-directional (Server can push)",
                        "Low overhead header"
                    ],
                    "cons": [
                        "Connection state management",
                        "Load balancing is trickier (sticky sessions)"
                    ],
                    "example": "Multiplayer games, Collaborative editing, Stock tickers."
                },
                {
                    "id": "webhooks",
                    "name": "Webhooks",
                    "icon": "Zap",
                    "description": "The server automatically sends data to your URL when something happens. No asking required.",
                    "analogy": "Don't call us, we'll call you.",
                    "flow": {
                        "title": "Stripe Payment Flow",
                        "steps": [
                            "1. User buys a T-Shirt on your site.",
                            "2. Payment is processed by Stripe (External Provider).",
                            "3. Stripe: 'Payment Successful!'",
                            "4. Stripe looks up your Webhook URL (e.g. your-site.com/api/payment-hook).",
                            "5. Stripe transmits data (HTTP POST) to your URL.",
                            "6. Your Server receives the data and ships the T-Shirt."
                        ]
                    },
                    "qa": [
                        {
                            "q": "Do I need a server?",
                            "a": "Yes. You need a public URL (endpoint) to receive the data from the provider."
                        },
                        {
                            "q": "What if my server is down?",
                            "a": "The provider usually retries sending the webhook for a while (exponential backoff). If you're down too long, you miss the event."
                        },
                        {
                            "q": "How do I know it's really Stripe?",
                            "a": "Security! You verify the cryptographic signature in the header to ensure the data came from them."
                        }
                    ],
                    "pros": [
                        "No polling required (Server Push)",
                        "Efficient for event-driven workflows"
                    ],
                    "cons": [
                        "Client must have a public URL",
                        "Debugging can be hard (fire and forget)",
                        "Security (verifying sender)"
                    ],
                    "example": "Stripe payment confirmation, GitHub push events, Slack bots."
                }
            ]
        }
    }
}